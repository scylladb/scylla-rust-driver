#![cfg_attr(
    not(all(scylla_unstable, feature = "unstable-reconnect-policy")),
    expect(unreachable_pub)
)]

//! Policy that controls delays between connection pool fill attempts.
//!
//! UNSTABLE API, guarded by `scylla_unstable` cfg and `unstable-reconnect-policy` feature.

use std::time::Duration;

/// Generated by [ReconnectPolicy] to control the delay between connection
/// attempts in a single connection pool.
///
/// In the current implementation, pool performs fills in batches.
/// [`on_fill_error()`](Self::on_fill_error) is called if any connection attempt in the batch failed.
/// [`on_successful_fill()`](Self::on_successful_fill) is called if all connection attempts in the batch succeeded.
pub trait ReconnectPolicySession: Send + std::fmt::Debug {
    /// Tells the pool how long to wait before attempting to fill connections to the host.
    fn get_delay(&self) -> Duration;
    /// Called when all connection attempts in the batch succeeded.
    fn on_successful_fill(&mut self);
    /// Called when any connection attempt in the batch failed.
    fn on_fill_error(&mut self);
}

/// Policy for controlling delays between connection pool fill attempts.
///
/// Because such policy may require mutable state (to handle fill failures),
/// this trait is not used directly by connection pools. Instead, the only
/// purpose of this trait is to generate boxed instances of per-host policy objects.
/// The generated objects are used by a single pool, and so can have methods with `&mut self`.
pub trait ReconnectPolicy: Send + Sync + std::fmt::Debug {
    /// Returns a new instance of the policy for the single host.
    fn new_session(&self) -> Box<dyn ReconnectPolicySession>;
}

#[derive(Debug)]
struct HostExponentialReconnectPolicy {
    min_fill_backoff: Duration,
    max_fill_backoff: Duration,
    current_delay: Duration,
}

impl ReconnectPolicySession for HostExponentialReconnectPolicy {
    fn get_delay(&self) -> Duration {
        self.current_delay
    }

    fn on_successful_fill(&mut self) {
        self.current_delay = self.min_fill_backoff;
    }

    fn on_fill_error(&mut self) {
        self.current_delay =
            std::cmp::min(self.max_fill_backoff, self.current_delay.saturating_mul(2));
    }
}

/// Reconnect policy that exponentially increases the delay between connection pool fill attempts.
///
/// Minimum and maximum delays can be configured.
#[derive(Debug)]
pub struct ExponentialReconnectPolicy {
    min_fill_backoff: Duration,
    max_fill_backoff: Duration,
}

#[cfg_attr(
    not(all(scylla_unstable, feature = "unstable-reconnect-policy")),
    expect(dead_code)
)]
impl ExponentialReconnectPolicy {
    /// Creates a new exponential reconnect policy with default values.
    pub fn new() -> Self {
        let min_fill_backoff = Duration::from_millis(50);
        Self {
            min_fill_backoff,
            max_fill_backoff: Duration::from_secs(10),
        }
    }

    /// Configures the minimum and maximum backoff durations for exponential backoff.
    ///
    /// The delay between fill attempts will be exponentially increased starting from `min` up to `max`.
    pub fn with_backoff_limits(self, min: Duration, max: Duration) -> Self {
        assert!(
            min <= max,
            "min_fill_backoff ({:?}) must be less than or equal to max_fill_backoff ({:?})",
            min,
            max
        );
        Self {
            min_fill_backoff: min,
            max_fill_backoff: max,
            ..self
        }
    }
}

impl Default for ExponentialReconnectPolicy {
    fn default() -> Self {
        Self::new()
    }
}

impl ReconnectPolicy for ExponentialReconnectPolicy {
    fn new_session(&self) -> Box<dyn ReconnectPolicySession> {
        Box::new(HostExponentialReconnectPolicy {
            min_fill_backoff: self.min_fill_backoff,
            max_fill_backoff: self.max_fill_backoff,
            current_delay: self.min_fill_backoff,
        })
    }
}

/// Constant reconnect policy.
/// This policy always returns the same delay.
#[derive(Debug, Clone)]
pub struct ConstantReconnectPolicy {
    delay: Duration,
}

#[cfg_attr(
    not(all(scylla_unstable, feature = "unstable-reconnect-policy")),
    expect(dead_code)
)]
impl ConstantReconnectPolicy {
    /// Creates a new constant reconnect policy with the given delay.
    pub fn new(duration: Duration) -> Self {
        Self { delay: duration }
    }
}

impl ReconnectPolicy for ConstantReconnectPolicy {
    fn new_session(&self) -> Box<dyn ReconnectPolicySession> {
        Box::new(self.clone())
    }
}

// ConstantReconnectPolicy doesn't have any mutable state,
// so we can avoid having another struct for per-host policy.
impl ReconnectPolicySession for ConstantReconnectPolicy {
    fn get_delay(&self) -> Duration {
        self.delay
    }

    fn on_successful_fill(&mut self) {}

    fn on_fill_error(&mut self) {}
}
